/*
 *  This file is a part of Altair, a chess engine.
 *  Copyright (C) 2017-2023 Sean Gillespie <sean@swgillespie.me>.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <iostream>
#include <vector>

#include "attacks.h"
#include "bitboard.h"
#include "types.h"

namespace altair {

/**
 * A simple, constexpr Xorshift64star RNG.
 *
 * https://en.wikipedia.org/wiki/Xorshift#xorshift*
 */
class Rng {
 public:
  explicit constexpr Rng(uint64_t seed) : state_(seed) {}

  constexpr uint64_t rand64() {
    state_ ^= state_ >> 12;
    state_ ^= state_ << 25;
    state_ ^= state_ >> 27;
    return state_ * 0x2545F4914F6CDD1DULL;
  }

 private:
  uint64_t state_;
};

template <PieceKind Kind>
uint64_t generate_magic(Square sq, int& table_size) {
  Bitboard edges = ((kBBRank1 | kBBRank8) & ~rank_bb(rank_of(sq))) |
                   ((kBBFileA | kBBFileH) & ~file_bb(file_of(sq)));

  SquareMagic magic;
  magic.mask = sliding_attack<Kind>(sq, Bitboard()) & ~edges;
  magic.shift = 64 - magic.mask.size();

  // This trick is called "Carry-Rippler" - it's a bit hack to enumerate the
  // power set of the bitboard "magic.mask", which itself determines how
  // many attack boards this particular magic can address.
  std::vector<Bitboard> occupancies;
  std::vector<Bitboard> attacks;
  Bitboard occupancyBoard;
  int size = 0;
  do {
    occupancies.push_back(occupancyBoard);
    attacks.push_back(sliding_attack<Kind>(sq, occupancyBoard));
    size++;
    occupancyBoard =
        Bitboard(occupancyBoard.bits() - magic.mask.bits()) & magic.mask;
  } while (!occupancyBoard.empty());

  Rng rng(2559);
  while (true) {
    std::vector<Bitboard> candidate_attack_table(size, ~Bitboard());
    do {
      magic.magic = rng.rand64() & rng.rand64() & rng.rand64();
    } while (Bitboard(magic.magic * magic.mask.bits()).size() < 6);

    bool failed = false;
    for (int i = 0; i < size; i++) {
      unsigned index = magic.index(occupancies[i]);
      if (candidate_attack_table[index] == ~Bitboard() ||
          candidate_attack_table[index] == attacks[i]) {
        candidate_attack_table[index] = attacks[i];
        continue;
      }

      failed = true;
      break;
    }

    if (!failed) {
      table_size += size;
      return magic.magic;
    }
  }
}

void generate_all_magics() {
  int bishop_table_size = 0;
  int rook_table_size = 0;

  std::cout << "/*" << std::endl;
  std::cout << " *  This file is a part of Altair, a chess engine." << std::endl;
  std::cout
      << " *  Copyright (C) 2017-2023 Sean Gillespie <sean@swgillespie.me>."
      << std::endl;
  std::cout << " *" << std::endl;
  std::cout << " *  This program is free software: you can redistribute it "
               "and/or modify"
            << std::endl;
  std::cout << " *  it under the terms of the GNU General Public License as "
               "published by"
            << std::endl;
  std::cout
      << " *  the Free Software Foundation, either version 3 of the License, or"
      << std::endl;
  std::cout << " *  (at your option) any later version." << std::endl;
  std::cout << " *" << std::endl;
  std::cout
      << " *  This program is distributed in the hope that it will be useful,"
      << std::endl;
  std::cout
      << " *  but WITHOUT ANY WARRANTY; without even the implied warranty of"
      << std::endl;
  std::cout
      << " *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"
      << std::endl;
  std::cout << " *  GNU General Public License for more details." << std::endl;
  std::cout << " *" << std::endl;
  std::cout
      << " *  You should have received a copy of the GNU General Public License"
      << std::endl;
  std::cout << " *  along with this program.  If not, see "
               "<https://www.gnu.org/licenses/>."
            << std::endl;
  std::cout << " */" << std::endl;
  std::cout << std::endl;
  std::cout
      << "// This file is autogenerated and should not be edited manually."
      << std::endl;
  std::cout << "// Re-run gen_magics.cc to re-generate." << std::endl;
  std::cout << std::endl;
  std::cout << "#include <cstdint>" << std::endl << std::endl;
  std::cout << "#include \"bitboard.h\"" << std::endl << std::endl;
  std::cout << std::endl << std::endl;
  std::cout << "namespace altair::attacks {" << std::endl;
  std::cout << "uint64_t kBishopMagics[64] = {" << std::endl;
  for (int i = A1; i < kSquareLast; i++) {
    std::cout << "  "
              << generate_magic<kBishop>(static_cast<Square>(i),
                                         bishop_table_size)
              << "ULL," << std::endl;
  }
  std::cout << "};" << std::endl << std::endl;
  std::cout << "Bitboard kBishopMagicAttacks[" << bishop_table_size << "];"
            << std::endl
            << std::endl;
  std::cout << std::endl << "uint64_t kRookMagics[64] = {" << std::endl;
  for (int i = A1; i < kSquareLast; i++) {
    std::cout << "  "
              << generate_magic<kRook>(static_cast<Square>(i), rook_table_size)
              << "ULL," << std::endl;
  }
  std::cout << "};" << std::endl << std::endl;
  std::cout << "Bitboard kRookMagicAttacks[" << rook_table_size << "];"
            << std::endl
            << std::endl;
  std::cout << std::endl << "} //  namespace altair::attacks" << std::endl;
}

}  // namespace altair

int main() { altair::generate_all_magics(); }

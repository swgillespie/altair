/*
 *  This file is a part of Altair, a chess engine.
 *  Copyright (C) 2017-2023 Sean Gillespie <sean@swgillespie.me>.
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "attacks.h"

#include <array>
#include <cstdint>
#include <vector>

#include "bitboard.h"
#include "types.h"

namespace altair::attacks {

// Defined in magics.cc (autogenerated by gen_magics.cc)
extern uint64_t kRookMagics[kSquareLast];
extern uint64_t kBishopMagics[kSquareLast];
extern Bitboard kBishopMagicAttacks[];
extern Bitboard kRookMagicAttacks[];

namespace {

/**
 * Lookup table for king attacks.
 */
class KingTable {
 public:
  consteval KingTable() {
    for (int i = 0; i < kSquareLast; i++) {
      Square sq = static_cast<Square>(i);
      Bitboard board;
      if (!kBBRank8.test(sq)) {
        board.set(towards(sq, kDirectionNorth));
        if (!kBBFileA.test(sq)) {
          board.set(towards(sq, kDirectionNorthWest));
        }
        if (!kBBFileH.test(sq)) {
          board.set(towards(sq, kDirectionNorthEast));
        }
      }

      if (!kBBRank1.test(sq)) {
        board.set(towards(sq, kDirectionSouth));
        if (!kBBFileA.test(sq)) {
          board.set(towards(sq, kDirectionSouthWest));
        }
        if (!kBBFileH.test(sq)) {
          board.set(towards(sq, kDirectionSouthEast));
        }
      }

      if (!kBBFileA.test(sq)) {
        board.set(towards(sq, kDirectionWest));
      }
      if (!kBBFileH.test(sq)) {
        board.set(towards(sq, kDirectionEast));
      }
      table_[i] = board;
    }
  }

  constexpr Bitboard attacks(Square sq) const { return table_[sq]; }

 private:
  std::array<Bitboard, kSquareLast> table_;
};

/**
 * Lookup table for pawn attacks, indexed by the side to move and by the square
 * of the pawn.
 */
class PawnTable {
 public:
  consteval PawnTable() {
    for (int i = A1; i < kSquareLast; i++) {
      Square sq = static_cast<Square>(i);
      for (auto color : {kWhite, kBlack}) {
        Bitboard board;
        Bitboard promo_rank = color == kWhite ? kBBRank8 : kBBRank1;
        Direction up_left =
            color == kWhite ? kDirectionNorthWest : kDirectionSouthWest;
        Direction up_right =
            color == kWhite ? kDirectionNorthEast : kDirectionSouthEast;

        if (promo_rank.test(sq)) {
          // No legal moves for this particular pawn. It's generally impossible
          // for pawns to be on the promotion rank anyway since they should have
          // been promoted already.
          continue;
        }

        if (!kBBFileA.test(sq)) {
          board.set(towards(sq, up_left));
        }
        if (!kBBFileH.test(sq)) {
          board.set(towards(sq, up_right));
        }
        table_[i][color] = board;
      }
    }
  }

  constexpr Bitboard attacks(Square sq, Color side) const {
    return table_[sq][side];
  }

 private:
  std::array<std::array<Bitboard, kColorLast>, kSquareLast> table_;
};

/**
 * Lookup table for knight attacks.
 */
class KnightTable {
 public:
  consteval KnightTable() {
    for (int i = 0; i < kSquareLast; i++) {
      Square sq = static_cast<Square>(i);
      Bitboard board;
      // Tedious, but correct. There are 8 possible knight moves, so we test
      // them all here to see if they run off the board.
      //
      // Knights don't care about occupancy; the occupancy of the target square
      // will be considered during movegen.
      if (!kBBFileA.test(sq) && !kBBRank78.test(sq)) {
        board.set(
            towards(sq, kDirectionNorth + kDirectionNorth + kDirectionWest));
      }
      if (!kBBFileH.test(sq) && !kBBRank78.test(sq)) {
        board.set(
            towards(sq, kDirectionNorth + kDirectionNorth + kDirectionEast));
      }
      if (!kBBFileGH.test(sq) && !kBBRank8.test(sq)) {
        board.set(
            towards(sq, kDirectionNorth + kDirectionEast + kDirectionEast));
      }
      if (!kBBFileGH.test(sq) && !kBBRank1.test(sq)) {
        board.set(
            towards(sq, kDirectionSouth + kDirectionEast + kDirectionEast));
      }
      if (!kBBFileH.test(sq) && !kBBRank12.test(sq)) {
        board.set(
            towards(sq, kDirectionSouth + kDirectionSouth + kDirectionEast));
      }
      if (!kBBFileA.test(sq) && !kBBRank12.test(sq)) {
        board.set(
            towards(sq, kDirectionSouth + kDirectionSouth + kDirectionWest));
      }
      if (!kBBFileAB.test(sq) && !kBBRank1.test(sq)) {
        board.set(
            towards(sq, kDirectionSouth + kDirectionWest + kDirectionWest));
      }
      if (!kBBFileAB.test(sq) && !kBBRank8.test(sq)) {
        board.set(
            towards(sq, kDirectionNorth + kDirectionWest + kDirectionWest));
      }

      table_[sq] = board;
    }
  }

  constexpr Bitboard attacks(Square sq) const { return table_[sq]; }

 private:
  std::array<Bitboard, kSquareLast> table_;
};

/**
 * Magic tables for "fancy magic bitboards"
 * (https://www.chessprogramming.org/Magic_Bitboards#Fancy).
 * gen_magics.cc pre-computes good magic numbers for us; we need to partially
 * re-compute SquareMagics for each square while re-using the pre-computed
 * magic.
 */
template <PieceKind Kind>
class Magics {
 public:
  explicit Magics(Bitboard* attack_table) {
    // This function mirrors logic in gen_magics.cc, except we don't try to
    // generate magics; we'll just use the pre-computed ones.
    //
    // The maximum number of attacks addressable by a single SquareMagic is 4096
    // (2^12), since a rook in the corner of the board has 12 relevant occupancy
    // squares.
    constexpr uint64_t* Magics = Kind == kBishop ? kBishopMagics : kRookMagics;
    Bitboard occupancies[4096], attacks[4096];
    for (int s = A1; s < kSquareLast; s++) {
      SquareMagic& magic = magics_[s];
      Square sq = static_cast<Square>(s);
      Bitboard edges = ((kBBRank1 | kBBRank8) & ~rank_bb(rank_of(sq))) |
                       ((kBBFileA | kBBFileH) & ~file_bb(file_of(sq)));

      magic.mask = sliding_attack<Kind>(sq, Bitboard()) & ~edges;
      magic.shift = 64 - magic.mask.size();
      magic.attack_ptr = attack_table;
      magic.magic = Magics[s];
      Bitboard occupancyBoard;
      int size = 0;

      // This trick is called "Carry-Rippler" - it's a bit hack to enumerate the
      // power set of the bitboard "magic.mask", which itself determines how
      // many attack boards this particular magic can address.
      do {
        occupancies[size] = occupancyBoard;
        attacks[size] = sliding_attack<Kind>(sq, occupancyBoard);
        size++;
        occupancyBoard =
            Bitboard(occupancyBoard.bits() - magic.mask.bits()) & magic.mask;
      } while (!occupancyBoard.empty());

      for (int i = 0; i < size; i++) {
        unsigned index = magic.index(occupancies[i]);
        magic.attack_ptr[index] = attacks[i];
      }

      attack_table += size;
    }
  }

  Bitboard attacks(Square sq, Bitboard occupancy) const {
    const SquareMagic& magic = magics_[sq];
    return magic.attack_ptr[magic.index(occupancy)];
  }

 private:
  std::array<SquareMagic, kSquareLast> magics_;
};

KingTable kKingTable = KingTable();
PawnTable kPawnTable = PawnTable();
KnightTable kKnightTable = KnightTable();
Magics<kBishop> kBishopTable = Magics<kBishop>(kBishopMagicAttacks);
Magics<kRook> kRookTable = Magics<kRook>(kRookMagicAttacks);

}  // namespace

Bitboard kings(Square sq) { return kKingTable.attacks(sq); }
Bitboard pawns(Square sq, Color side) { return kPawnTable.attacks(sq, side); }
Bitboard knights(Square sq) { return kKnightTable.attacks(sq); }
Bitboard bishops(Square sq, Bitboard occupancy) {
  return kBishopTable.attacks(sq, occupancy);
}
Bitboard rooks(Square sq, Bitboard occupancy) {
  return kRookTable.attacks(sq, occupancy);
}

}  // namespace altair::attacks
